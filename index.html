<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AI Analyst: CS2 Market ‚Äî real skins loader</title>
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  :root{--bg:#f5f5f5;--accent:#facc00;--card:#fff;--text:#222}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; background:var(--bg);color:var(--text)}
  header{padding:14px;text-align:center;background:#081025;color:white}
  header h1{margin:0;font-size:18px}
  .wrap{padding:12px}
  .buttons{display:flex;gap:8px;justify-content:center;flex-wrap:wrap}
  .btn{padding:10px 14px;border-radius:10px;border:2px solid var(--accent);background:var(--card);cursor:pointer;font-weight:700}
  .list{display:flex;flex-wrap:wrap;gap:10px;justify-content:center;margin-top:12px}
  .card{width:150px;background:var(--card);border:2px solid var(--accent);border-radius:12px;padding:8px;text-align:center;cursor:pointer}
  .card img{width:100px;height:80px;object-fit:contain}
  .back{margin-top:12px;padding:8px 12px;border-radius:8px;border:2px solid var(--accent);background:var(--card);cursor:pointer;display:inline-block}
  .meta{margin-top:8px;font-size:13px}
  .trend-up{color:#0a0;font-weight:700}
  .trend-down{color:#a00;font-weight:700}
  .warn{margin-top:14px;padding:10px;border-radius:8px;background:#fff0d6;border:1px solid #f0c86a;text-align:center}
  #loading{opacity:.9;position:fixed;left:12px;bottom:12px;padding:8px 12px;border-radius:10px;background:#000000cc;color:white}
  .controls{display:flex;gap:8px;justify-content:center;align-items:center;margin-top:8px}
  label{font-weight:700;margin-right:6px}
  select{padding:6px;border-radius:6px;border:1px solid #ddd}
  canvas{max-width:100%}
  footer{padding:10px;text-align:center;font-size:12px;color:#666}
</style>
</head>
<body>
<header>
  <h1>AI Analyst: CS2 Market ‚Äî Realtime Skins (up to 500)</h1>
</header>

<div class="wrap" id="screen1">
  <div class="buttons">
    <button class="btn" data-cat="knives">–ù–æ–∂–∏</button>
    <button class="btn" data-cat="weapons">–û—Ä—É–∂–∏–µ</button>
    <button class="btn" data-cat="agents">–ê–≥–µ–Ω—Ç—ã</button>
  </div>
  <div class="controls" style="margin-top:14px">
    <label for="maxItems">–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –¥–æ</label>
    <select id="maxItems"><option>100</option><option selected>200</option><option>300</option><option>400</option><option>500</option></select>
    <button class="btn" id="refreshBtn">–û–±–Ω–æ–≤–∏—Ç—å —Å–µ–π—á–∞—Å</button>
  </div>
</div>

<div class="wrap" id="screen2" style="display:none">
  <h2 id="categoryTitle" style="text-align:center;color:var(--accent)"></h2>
  <div id="itemsList" class="list"></div>
  <div style="text-align:center"><span class="back" id="toMain">‚¨Ö –ù–∞–∑–∞–¥</span></div>
</div>

<div class="wrap" id="screen3" style="display:none">
  <h2 id="detailName" style="text-align:center;color:var(--accent)"></h2>
  <div style="text-align:center"><img id="detailImg" src="" style="width:180px;height:140px;object-fit:contain;border-radius:6px;background:#fff;padding:6px"></div>

  <div style="display:flex;gap:10px;justify-content:center;align-items:center;margin-top:8px">
    <label for="variantSelect">–°–æ—Å—Ç–æ—è–Ω–∏–µ:</label>
    <select id="variantSelect"></select>
  </div>

  <div style="text-align:center;margin-top:10px">
    <div>–¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞: $<span id="detailPrice">‚Äî</span></div>
    <div>–ü—Ä–æ–≥–Ω–æ–∑: <span id="detailTrend">‚Äî</span></div>
    <div>–†–µ–Ω—Ç–∞–±–µ–ª—å–Ω–æ—Å—Ç—å: <span id="detailProfit">‚Äî</span>%</div>
  </div>

  <canvas id="detailChart" style="margin-top:12px"></canvas>

  <div style="text-align:center"><span class="back" id="toList">‚¨Ö –ù–∞–∑–∞–¥ –∫ —Å–ø–∏—Å–∫—É</span></div>
</div>

<div id="loading" style="display:none">–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö ‚Äî –ø—Ä–æ–±—É—é HuggingFace dataset...</div>

<div id="notice" class="warn" style="display:none">
  –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞—Ç–∞—Å–µ—Ç –Ω–∞–ø—Ä—è–º—É—é –∏–∑ HuggingFace (–≤–æ–∑–º–æ–∂–Ω–æ CORS). <br>
  –ù–∞–∂–º–∏—Ç–µ <strong>¬´–°–∫–∞—á–∞—Ç—å JSON¬ª</strong>, –∑–∞—Ç–µ–º –ø–æ–ª–æ–∂–∏—Ç–µ —Ñ–∞–π–ª `cs2-data.json` –≤ –∫–æ—Ä–µ–Ω—å —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è –∏ –∏–∑–º–µ–Ω–∏—Ç–µ –ø—É—Ç—å –≤ –∫–æ–¥–µ (—É–∫–∞–∑–∞–Ω–æ –≤ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏).
  <div style="margin-top:8px"><button class="btn" id="downloadBtn">–°–∫–∞—á–∞—Ç—å JSON</button></div>
</div>

<footer>–ï—Å–ª–∏ –Ω—É–∂–µ–Ω ‚Äî –º–æ–≥—É —Å–¥–µ–ª–∞—Ç—å –∑–∞–≥—Ä—É–∑–∫—É —á–µ—Ä–µ–∑ —Ç–≤–æ–π –±–æ—Ç (API) –∏–ª–∏ —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å JSON —É —Ç–µ–±—è –Ω–∞ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏.</footer>

<script>
/*
  –≠—Ç–æ—Ç —Ñ–∞–π–ª –ø—ã—Ç–∞–µ—Ç—Å—è –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Å–∫–∏–Ω–æ–≤ –∏–∑ –ø—É–±–ª–∏—á–Ω–æ–≥–æ –¥–∞—Ç–∞—Å–µ—Ç–∞:
  HuggingFace: While402/CounterStrike2Skins (metadata).
  URL (resolve): https://huggingface.co/datasets/While402/CounterStrike2Skins/resolve/main/metadata.csv

  –ï—Å–ª–∏ —É —Ç–µ–±—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ CORS, —Å–∫–∞—á–∞–π CSV –ª–æ–∫–∞–ª—å–Ω–æ, –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–π –≤ JSON –∏ –ø–æ–º–µ—Å—Ç–∏ –≤ —Ä–µ–ø–æ –∫–∞–∫ cs2-data.json.
*/

const HF_CSV = 'https://huggingface.co/datasets/While402/CounterStrike2Skins/resolve/main/metadata.csv';
const FALLBACK_JSON = './cs2-data.json'; // –µ—Å–ª–∏ –∑–∞–≥—Ä—É–∑–∫–∞ HF –Ω–µ –ø—Ä–æ—Ö–æ–¥–∏—Ç ‚Äî –∏—Å–ø–æ–ª—å–∑—É–π –ª–æ–∫–∞–ª—å–Ω—ã–π —Ñ–∞–π–ª

let ITEMS_BY_NAME = {}; // { name: { name, category, image, variants: [...] } }
let CURRENT_CATEGORY = null;
let CURRENT_SKIN = null;
let chartInstance = null;

const MAX_DEFAULT = 200;

const loadingEl = document.getElementById('loading');
const noticeEl = document.getElementById('notice');
const downloadBtn = document.getElementById('downloadBtn');

document.getElementById('maxItems').value = String(MAX_DEFAULT);

function showLoading(on){
  loadingEl.style.display = on ? 'block' : 'none';
}

async function fetchCSVorJSON(){
  showLoading(true);
  // –ü–æ–ø—Ä–æ–±—É–µ–º —Å–Ω–∞—á–∞–ª–∞ HuggingFace CSV
  try {
    const res = await fetch(HF_CSV);
    if(!res.ok) throw new Error('HuggingFace responded ' + res.status);
    const csv = await res.text();
    parseCSVtoItems(csv);
    showLoading(false);
    return;
  } catch(e){
    console.warn('HF CSV failed:', e);
  }

  // –µ—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å ‚Äî –ø–æ–ø—ã—Ç–∞–µ–º—Å—è –∑–∞–≥—Ä—É–∑–∏—Ç—å –ª–æ–∫–∞–ª—å–Ω—ã–π JSON
  try {
    const res2 = await fetch(FALLBACK_JSON);
    if(!res2.ok) throw new Error('Local JSON not found');
    const data = await res2.json();
    buildItemsFromJSON(data);
    showLoading(false);
    return;
  } catch(e){
    console.warn('Fallback JSON failed:', e);
  }

  // –µ—Å–ª–∏ –æ–±–∞ –Ω–µ –ø—Ä–æ—à–ª–∏ ‚Äî –ø–æ–∫–∞–∂–µ–º –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é
  showLoading(false);
  noticeEl.style.display = 'block';
}

// –ü–∞—Ä—Å–µ—Ä –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π –ª–æ–≥–∏–∫–∏ CSV -> items grouped
// –û–∂–∏–¥–∞–µ–º, —á—Ç–æ —É CSV –µ—Å—Ç—å –∫–æ–ª–æ–Ω–∫–∏: name, exterior, weapon, rarity, imageid (—Å–º. dataset preview)
// –§–æ—Ä–º–∏—Ä—É–µ–º –æ–±—ä–µ–∫—Ç—ã: baseName (–±–µ–∑ " (Factory New)") -> variants []
function parseCSVtoItems(csvText){
  ITEMS_BY_NAME = {};
  const lines = csvText.split(/\r?\n/).filter(l=>l.trim());
  // –û–ø—Ä–µ–¥–µ–ª–∏–º –∑–∞–≥–æ–ª–æ–≤–∫–∏ (–ø–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞)
  const header = lines[0].split(',');
  const idxName = header.findIndex(h => /name/i.test(h));
  const idxExterior = header.findIndex(h => /exterior/i.test(h));
  const idxWeapon = header.findIndex(h => /weapon/i.test(h));
  const idxImageid = header.findIndex(h => /imageid/i.test(h));
  // –ï—Å–ª–∏ –Ω–µ—Ç –∑–∞–≥–æ–ª–æ–≤–∫–∞ ‚Äî –ø–æ–ø—Ä–æ–±—É–µ–º –±–µ–∑ –Ω–µ–≥–æ
  let start = 1;
  if(idxName === -1){
    // assume no header: try common indices
    start = 0;
  }

  for(let i=start;i<lines.length;i++){
    const row = lines[i];
    // split on comma but CSV may have commas in names ‚Äî use simple split for now, it's best-effort
    const cols = row.split(',');
    const rawName = cols[idxName] ? cols[idxName].replace(/^"|"$/g,'').trim() : (cols[0]||'').trim();
    if(!rawName) continue;
    // rawName often has " (Factory New)" suffix ‚Äî separate
    const exteriorMatch = rawName.match(/\s*\((Factory New|Minimal Wear|Field-Tested|Well-Worn|Battle-Scarred|Fresh|Standard|Battle Scarred|MinimalWear)\)$/i);
    let exterior = exteriorMatch ? exteriorMatch[1] : (cols[idxExterior] ? cols[idxExterior].replace(/^"|"$/g,'').trim() : '');
    // base name without parenthesis endings
    const baseName = rawName.replace(/\s*\((Factory New|Minimal Wear|Field-Tested|Well-Worn|Battle-Scarred|Fresh|Standard|Battle Scarred|MinimalWear)\)$/i,'').trim();
    const weapon = cols[idxWeapon] ? cols[idxWeapon].replace(/^"|"$/g,'').trim() : '';
    const imageid = cols[idxImageid] ? cols[idxImageid].replace(/^"|"$/g,'').trim() : '';
    // Build image URL guess if imageid exists (dataset may not include full image links)
    // HuggingFace dataset includes image files; but direct linking would need dataset files. We'll attempt to construct a preview image via huggingface 'raw' image path if imageid present:
    let imageUrl = '';
    if(imageid){
      // best-effort: dataset stores images/0001.png - try to reference them via dataset raw path
      const imgIdx = imageid.replace(/^0+/, ''); // naive
      imageUrl = `https://huggingface.co/datasets/While402/CounterStrike2Skins/resolve/main/images/${imageid}.png`;
    }

    // create entry
    if(!ITEMS_BY_NAME[baseName]){
      ITEMS_BY_NAME[baseName] = {
        name: baseName,
        weapon: weapon || '',
        image: imageUrl,
        variants: []
      };
    }
    // push variant
    ITEMS_BY_NAME[baseName].variants.push({
      condition: exterior || 'Standard',
      price: null, // price not available in this metadata CSV ‚Äî server/bot should provide
      trend: 'unknown',
      profit: 0,
      history: []
    });
  }

  // After parse, convert to array and limit to MAX
  console.log('parsed names:', Object.keys(ITEMS_BY_NAME).length);
}

// –ï—Å–ª–∏ —É —Ç–µ–±—è —É–∂–µ –µ—Å—Ç—å JSON –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ —Å –Ω—É–∂–Ω–æ–π –ø–æ–ª—è–º–∏ ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ –Ω–∞–ø—Ä—è–º—É—é
function buildItemsFromJSON(data){
  ITEMS_BY_NAME = {};
  data.forEach(item=>{
    const baseName = item.name;
    ITEMS_BY_NAME[baseName] = {
      name: item.name,
      weapon: item.weapon || item.category || '',
      image: item.image || '',
      variants: (item.variants || []).map(v=>({
        condition: v.condition || 'Standard',
        price: v.price || null,
        trend: v.trend || 'unknown',
        profit: v.profit || 0,
        history: v.history || []
      }))
    };
  });
}

// UI helpers
function showCategory(cat){
  CURRENT_CATEGORY = cat;
  document.getElementById('screen1').style.display = 'none';
  document.getElementById('screen2').style.display = 'block';
  document.getElementById('screen3').style.display = 'none';
  document.getElementById('categoryTitle').textContent = cat === 'knives' ? '–ù–æ–∂–∏' : cat === 'weapons' ? '–û—Ä—É–∂–∏–µ' : '–ê–≥–µ–Ω—Ç—ã';
  renderList();
}

function renderList(){
  const container = document.getElementById('itemsList');
  container.innerHTML = '';
  const maxItems = parseInt(document.getElementById('maxItems').value,10) || 200;
  // Build array from ITEMS_BY_NAME; filter by weapon type containing category (best-effort)
  const arr = Object.values(ITEMS_BY_NAME).filter(it=>{
    if(!CURRENT_CATEGORY) return true;
    const cat = CURRENT_CATEGORY;
    // simple mapping: knives category -> weapon contains "Knife" or special char
    if(cat === 'knives'){
      return /knife/i.test(it.name) || /knife/i.test(it.weapon) || /‚òÖ/.test(it.name);
    }
    if(cat === 'weapons'){
      return !(/knife/i.test(it.name) || /agent/i.test(it.weapon) || /agent/i.test(it.name));
    }
    if(cat === 'agents'){
      return /agent/i.test(it.weapon) || /agent/i.test(it.name);
    }
    return true;
  }).slice(0, maxItems);

  if(arr.length === 0){
    container.innerHTML = '<div style="padding:20px;color:#666">–ù–µ –Ω–∞–π–¥–µ–Ω–æ –ø—Ä–µ–¥–º–µ—Ç–æ–≤ –¥–ª—è —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ (–¥–∞–Ω–Ω—ã–µ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã)</div>';
    return;
  }

  arr.forEach(it=>{
    const card = document.createElement('div');
    card.className = 'card';
    const img = document.createElement('img');
    img.src = it.image || 'https://via.placeholder.com/150?text=No+img';
    img.alt = it.name;
    const title = document.createElement('div');
    title.style.fontWeight='700';
    title.style.marginTop='6px';
    title.textContent = it.name;
    card.appendChild(img);
    card.appendChild(title);
    card.onclick = ()=> openDetail(it);
    container.appendChild(card);
  });
}

function openDetail(item){
  CURRENT_SKIN = item;
  document.getElementById('screen1').style.display = 'none';
  document.getElementById('screen2').style.display = 'none';
  document.getElementById('screen3').style.display = 'block';
  document.getElementById('detailName').textContent = item.name;
  document.getElementById('detailImg').src = item.image || 'https://via.placeholder.com/300?text=No+img';
  // fill variants
  const sel = document.getElementById('variantSelect');
  sel.innerHTML = '';
  item.variants.forEach((v,i)=>{
    const opt = document.createElement('option');
    opt.value = i;
    opt.textContent = v.condition;
    sel.appendChild(opt);
  });

  // Attempt to request real price & forecast from your bot API:
  // Endpoint expectation: GET /api/item?name=<encoded name> -> { name, image, variants: [{condition, price, trend, profit, history}] }
  // If your bot provides that endpoint, enable below function by setting BOT_API_BASE.
  updateVariantDisplay(item, 0);
  sel.onchange = ()=> updateVariantDisplay(item, parseInt(sel.value,10));
}

// Update visible data for variant index
function updateVariantDisplay(item, idx){
  const v = item.variants[idx];
  // If price missing, try to fetch from BOT API (if configured)
  document.getElementById('detailPrice').textContent = v.price !== null ? v.price : '‚Äî';
  document.getElementById('detailTrend').textContent = v.trend === 'up' ? 'üî∫ –†–æ—Å—Ç' : (v.trend === 'down' ? 'üîª –ü–∞–¥–µ–Ω–∏–µ' : '‚Äî');
  document.getElementById('detailTrend').className = v.trend === 'up' ? 'trend-up' : (v.trend === 'down' ? 'trend-down' : '');
  document.getElementById('detailProfit').textContent = v.profit !== undefined ? v.profit : '‚Äî';

  // draw chart (history may be empty)
  const history = (v.history && v.history.length) ? v.history : generateFakeHistory(v.price);
  drawChart(history);
  // Also ask bot backend for real detail if you have API (uncomment and set BOT_API)
  // fetchRealDetailIfAvailable(item.name);
}

// Simple fake history generator if none present (so UI not empty); not used for real analytics
function generateFakeHistory(price){
  const p = price || Math.round(Math.random()*200);
  const arr = [];
  for(let i=8;i>=0;i--){
    arr.push(Math.max(1, Math.round(p*(1 + (Math.random()-0.5)*0.06))));
  }
  return arr;
}

function drawChart(data){
  if(chartInstance){ chartInstance.destroy(); chartInstance = null; }
  const ctx = document.getElementById('detailChart').getContext('2d');
  chartInstance = new Chart(ctx, {
    type: 'line',
    data: {
      labels: data.map((_,i)=>`T-${data.length-i}`),
      datasets: [{
        label: '–¶–µ–Ω–∞ ($)',
        data: data,
        borderColor: '#facc00',
        backgroundColor: 'rgba(250,204,0,0.18)',
        tension: 0.25,
        pointRadius: 2
      }]
    },
    options: { responsive: true, plugins:{legend:{display:false}} }
  });
}

// --- events
document.querySelectorAll('.btn[data-cat]').forEach(b=> b.addEventListener('click', ()=> showCategory(b.dataset.cat)));
document.getElementById('toMain').onclick = ()=> { document.getElementById('screen2').style.display='none'; document.getElementById('screen1').style.display='block'; };
document.getElementById('toList').onclick = ()=> { document.getElementById('screen3').style.display='none'; document.getElementById('screen2').style.display='block'; if(chartInstance){chartInstance.destroy(); chartInstance=null;} };
document.getElementById('refreshBtn').onclick = ()=> { fetchCSVorJSON().then(()=> renderList()); };
downloadBtn.onclick = ()=> { window.open(HF_CSV, '_blank'); };

// Auto-load once
fetchCSVorJSON();

// Auto-refresh every 30s if view on category
setInterval(()=>{ if(CURRENT_CATEGORY) fetchCSVorJSON().then(()=> renderList()); }, 30000);
</script>
</body>
</html>
