<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AI Analyst: CS2 Market — real skins loader</title>
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  :root{--bg:#f5f5f5;--accent:#facc00;--card:#fff;--text:#222}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; background:var(--bg);color:var(--text)}
  header{padding:14px;text-align:center;background:#081025;color:white}
  header h1{margin:0;font-size:18px}
  .wrap{padding:12px}
  .buttons{display:flex;gap:8px;justify-content:center;flex-wrap:wrap}
  .btn{padding:10px 14px;border-radius:10px;border:2px solid var(--accent);background:var(--card);cursor:pointer;font-weight:700}
  .list{display:flex;flex-wrap:wrap;gap:10px;justify-content:center;margin-top:12px}
  .card{width:150px;background:var(--card);border:2px solid var(--accent);border-radius:12px;padding:8px;text-align:center;cursor:pointer}
  .card img{width:100px;height:80px;object-fit:contain}
  .back{margin-top:12px;padding:8px 12px;border-radius:8px;border:2px solid var(--accent);background:var(--card);cursor:pointer;display:inline-block}
  .meta{margin-top:8px;font-size:13px}
  .trend-up{color:#0a0;font-weight:700}
  .trend-down{color:#a00;font-weight:700}
  .warn{margin-top:14px;padding:10px;border-radius:8px;background:#fff0d6;border:1px solid #f0c86a;text-align:center}
  #loading{opacity:.9;position:fixed;left:12px;bottom:12px;padding:8px 12px;border-radius:10px;background:#000000cc;color:white}
  .controls{display:flex;gap:8px;justify-content:center;align-items:center;margin-top:8px}
  label{font-weight:700;margin-right:6px}
  select{padding:6px;border-radius:6px;border:1px solid #ddd}
  canvas{max-width:100%}
  footer{padding:10px;text-align:center;font-size:12px;color:#666}
</style>
</head>
<body>
<header>
  <h1>AI Analyst: CS2 Market — Realtime Skins (up to 500)</h1>
</header>

<div class="wrap" id="screen1">
  <div class="buttons">
    <button class="btn" data-cat="knives">Ножи</button>
    <button class="btn" data-cat="weapons">Оружие</button>
    <button class="btn" data-cat="agents">Агенты</button>
  </div>
  <div class="controls" style="margin-top:14px">
    <label for="maxItems">Показывать до</label>
    <select id="maxItems"><option>100</option><option selected>200</option><option>300</option><option>400</option><option>500</option></select>
    <button class="btn" id="refreshBtn">Обновить сейчас</button>
  </div>
</div>

<div class="wrap" id="screen2" style="display:none">
  <h2 id="categoryTitle" style="text-align:center;color:var(--accent)"></h2>
  <div id="itemsList" class="list"></div>
  <div style="text-align:center"><span class="back" id="toMain">⬅ Назад</span></div>
</div>

<div class="wrap" id="screen3" style="display:none">
  <h2 id="detailName" style="text-align:center;color:var(--accent)"></h2>
  <div style="text-align:center"><img id="detailImg" src="" style="width:180px;height:140px;object-fit:contain;border-radius:6px;background:#fff;padding:6px"></div>

  <div style="display:flex;gap:10px;justify-content:center;align-items:center;margin-top:8px">
    <label for="variantSelect">Состояние:</label>
    <select id="variantSelect"></select>
  </div>

  <div style="text-align:center;margin-top:10px">
    <div>Текущая цена: $<span id="detailPrice">—</span></div>
    <div>Прогноз: <span id="detailTrend">—</span></div>
    <div>Рентабельность: <span id="detailProfit">—</span>%</div>
  </div>

  <canvas id="detailChart" style="margin-top:12px"></canvas>

  <div style="text-align:center"><span class="back" id="toList">⬅ Назад к списку</span></div>
</div>

<div id="loading" style="display:none">Загрузка данных — пробую HuggingFace dataset...</div>

<div id="notice" class="warn" style="display:none">
  Не удалось загрузить датасет напрямую из HuggingFace (возможно CORS). <br>
  Нажмите <strong>«Скачать JSON»</strong>, затем положите файл `cs2-data.json` в корень репозитория и измените путь в коде (указано в инструкции).
  <div style="margin-top:8px"><button class="btn" id="downloadBtn">Скачать JSON</button></div>
</div>

<footer>Если нужен — могу сделать загрузку через твой бот (API) или разместить JSON у тебя на репозитории.</footer>

<script>
/*
  Этот файл пытается загрузить реальные данные скинов из публичного датасета:
  HuggingFace: While402/CounterStrike2Skins (metadata).
  URL (resolve): https://huggingface.co/datasets/While402/CounterStrike2Skins/resolve/main/metadata.csv

  Если у тебя блокировка CORS, скачай CSV локально, конвертируй в JSON и помести в репо как cs2-data.json.
*/

const HF_CSV = 'https://huggingface.co/datasets/While402/CounterStrike2Skins/resolve/main/metadata.csv';
const FALLBACK_JSON = './cs2-data.json'; // если загрузка HF не проходит — используй локальный файл

let ITEMS_BY_NAME = {}; // { name: { name, category, image, variants: [...] } }
let CURRENT_CATEGORY = null;
let CURRENT_SKIN = null;
let chartInstance = null;

const MAX_DEFAULT = 200;

const loadingEl = document.getElementById('loading');
const noticeEl = document.getElementById('notice');
const downloadBtn = document.getElementById('downloadBtn');

document.getElementById('maxItems').value = String(MAX_DEFAULT);

function showLoading(on){
  loadingEl.style.display = on ? 'block' : 'none';
}

async function fetchCSVorJSON(){
  showLoading(true);
  // Попробуем сначала HuggingFace CSV
  try {
    const res = await fetch(HF_CSV);
    if(!res.ok) throw new Error('HuggingFace responded ' + res.status);
    const csv = await res.text();
    parseCSVtoItems(csv);
    showLoading(false);
    return;
  } catch(e){
    console.warn('HF CSV failed:', e);
  }

  // если не получилось — попытаемся загрузить локальный JSON
  try {
    const res2 = await fetch(FALLBACK_JSON);
    if(!res2.ok) throw new Error('Local JSON not found');
    const data = await res2.json();
    buildItemsFromJSON(data);
    showLoading(false);
    return;
  } catch(e){
    console.warn('Fallback JSON failed:', e);
  }

  // если оба не прошли — покажем инструкцию
  showLoading(false);
  noticeEl.style.display = 'block';
}

// Парсер минимальной логики CSV -> items grouped
// Ожидаем, что у CSV есть колонки: name, exterior, weapon, rarity, imageid (см. dataset preview)
// Формируем объекты: baseName (без " (Factory New)") -> variants []
function parseCSVtoItems(csvText){
  ITEMS_BY_NAME = {};
  const lines = csvText.split(/\r?\n/).filter(l=>l.trim());
  // Определим заголовки (первая строка)
  const header = lines[0].split(',');
  const idxName = header.findIndex(h => /name/i.test(h));
  const idxExterior = header.findIndex(h => /exterior/i.test(h));
  const idxWeapon = header.findIndex(h => /weapon/i.test(h));
  const idxImageid = header.findIndex(h => /imageid/i.test(h));
  // Если нет заголовка — попробуем без него
  let start = 1;
  if(idxName === -1){
    // assume no header: try common indices
    start = 0;
  }

  for(let i=start;i<lines.length;i++){
    const row = lines[i];
    // split on comma but CSV may have commas in names — use simple split for now, it's best-effort
    const cols = row.split(',');
    const rawName = cols[idxName] ? cols[idxName].replace(/^"|"$/g,'').trim() : (cols[0]||'').trim();
    if(!rawName) continue;
    // rawName often has " (Factory New)" suffix — separate
    const exteriorMatch = rawName.match(/\s*\((Factory New|Minimal Wear|Field-Tested|Well-Worn|Battle-Scarred|Fresh|Standard|Battle Scarred|MinimalWear)\)$/i);
    let exterior = exteriorMatch ? exteriorMatch[1] : (cols[idxExterior] ? cols[idxExterior].replace(/^"|"$/g,'').trim() : '');
    // base name without parenthesis endings
    const baseName = rawName.replace(/\s*\((Factory New|Minimal Wear|Field-Tested|Well-Worn|Battle-Scarred|Fresh|Standard|Battle Scarred|MinimalWear)\)$/i,'').trim();
    const weapon = cols[idxWeapon] ? cols[idxWeapon].replace(/^"|"$/g,'').trim() : '';
    const imageid = cols[idxImageid] ? cols[idxImageid].replace(/^"|"$/g,'').trim() : '';
    // Build image URL guess if imageid exists (dataset may not include full image links)
    // HuggingFace dataset includes image files; but direct linking would need dataset files. We'll attempt to construct a preview image via huggingface 'raw' image path if imageid present:
    let imageUrl = '';
    if(imageid){
      // best-effort: dataset stores images/0001.png - try to reference them via dataset raw path
      const imgIdx = imageid.replace(/^0+/, ''); // naive
      imageUrl = `https://huggingface.co/datasets/While402/CounterStrike2Skins/resolve/main/images/${imageid}.png`;
    }

    // create entry
    if(!ITEMS_BY_NAME[baseName]){
      ITEMS_BY_NAME[baseName] = {
        name: baseName,
        weapon: weapon || '',
        image: imageUrl,
        variants: []
      };
    }
    // push variant
    ITEMS_BY_NAME[baseName].variants.push({
      condition: exterior || 'Standard',
      price: null, // price not available in this metadata CSV — server/bot should provide
      trend: 'unknown',
      profit: 0,
      history: []
    });
  }

  // After parse, convert to array and limit to MAX
  console.log('parsed names:', Object.keys(ITEMS_BY_NAME).length);
}

// Если у тебя уже есть JSON на сервере с нужной полями — используем его напрямую
function buildItemsFromJSON(data){
  ITEMS_BY_NAME = {};
  data.forEach(item=>{
    const baseName = item.name;
    ITEMS_BY_NAME[baseName] = {
      name: item.name,
      weapon: item.weapon || item.category || '',
      image: item.image || '',
      variants: (item.variants || []).map(v=>({
        condition: v.condition || 'Standard',
        price: v.price || null,
        trend: v.trend || 'unknown',
        profit: v.profit || 0,
        history: v.history || []
      }))
    };
  });
}

// UI helpers
function showCategory(cat){
  CURRENT_CATEGORY = cat;
  document.getElementById('screen1').style.display = 'none';
  document.getElementById('screen2').style.display = 'block';
  document.getElementById('screen3').style.display = 'none';
  document.getElementById('categoryTitle').textContent = cat === 'knives' ? 'Ножи' : cat === 'weapons' ? 'Оружие' : 'Агенты';
  renderList();
}

function renderList(){
  const container = document.getElementById('itemsList');
  container.innerHTML = '';
  const maxItems = parseInt(document.getElementById('maxItems').value,10) || 200;
  // Build array from ITEMS_BY_NAME; filter by weapon type containing category (best-effort)
  const arr = Object.values(ITEMS_BY_NAME).filter(it=>{
    if(!CURRENT_CATEGORY) return true;
    const cat = CURRENT_CATEGORY;
    // simple mapping: knives category -> weapon contains "Knife" or special char
    if(cat === 'knives'){
      return /knife/i.test(it.name) || /knife/i.test(it.weapon) || /★/.test(it.name);
    }
    if(cat === 'weapons'){
      return !(/knife/i.test(it.name) || /agent/i.test(it.weapon) || /agent/i.test(it.name));
    }
    if(cat === 'agents'){
      return /agent/i.test(it.weapon) || /agent/i.test(it.name);
    }
    return true;
  }).slice(0, maxItems);

  if(arr.length === 0){
    container.innerHTML = '<div style="padding:20px;color:#666">Не найдено предметов для этой категории (данные не загружены)</div>';
    return;
  }

  arr.forEach(it=>{
    const card = document.createElement('div');
    card.className = 'card';
    const img = document.createElement('img');
    img.src = it.image || 'https://via.placeholder.com/150?text=No+img';
    img.alt = it.name;
    const title = document.createElement('div');
    title.style.fontWeight='700';
    title.style.marginTop='6px';
    title.textContent = it.name;
    card.appendChild(img);
    card.appendChild(title);
    card.onclick = ()=> openDetail(it);
    container.appendChild(card);
  });
}

function openDetail(item){
  CURRENT_SKIN = item;
  document.getElementById('screen1').style.display = 'none';
  document.getElementById('screen2').style.display = 'none';
  document.getElementById('screen3').style.display = 'block';
  document.getElementById('detailName').textContent = item.name;
  document.getElementById('detailImg').src = item.image || 'https://via.placeholder.com/300?text=No+img';
  // fill variants
  const sel = document.getElementById('variantSelect');
  sel.innerHTML = '';
  item.variants.forEach((v,i)=>{
    const opt = document.createElement('option');
    opt.value = i;
    opt.textContent = v.condition;
    sel.appendChild(opt);
  });

  // Attempt to request real price & forecast from your bot API:
  // Endpoint expectation: GET /api/item?name=<encoded name> -> { name, image, variants: [{condition, price, trend, profit, history}] }
  // If your bot provides that endpoint, enable below function by setting BOT_API_BASE.
  updateVariantDisplay(item, 0);
  sel.onchange = ()=> updateVariantDisplay(item, parseInt(sel.value,10));
}

// Update visible data for variant index
function updateVariantDisplay(item, idx){
  const v = item.variants[idx];
  // If price missing, try to fetch from BOT API (if configured)
  document.getElementById('detailPrice').textContent = v.price !== null ? v.price : '—';
  document.getElementById('detailTrend').textContent = v.trend === 'up' ? '🔺 Рост' : (v.trend === 'down' ? '🔻 Падение' : '—');
  document.getElementById('detailTrend').className = v.trend === 'up' ? 'trend-up' : (v.trend === 'down' ? 'trend-down' : '');
  document.getElementById('detailProfit').textContent = v.profit !== undefined ? v.profit : '—';

  // draw chart (history may be empty)
  const history = (v.history && v.history.length) ? v.history : generateFakeHistory(v.price);
  drawChart(history);
  // Also ask bot backend for real detail if you have API (uncomment and set BOT_API)
  // fetchRealDetailIfAvailable(item.name);
}

// Simple fake history generator if none present (so UI not empty); not used for real analytics
function generateFakeHistory(price){
  const p = price || Math.round(Math.random()*200);
  const arr = [];
  for(let i=8;i>=0;i--){
    arr.push(Math.max(1, Math.round(p*(1 + (Math.random()-0.5)*0.06))));
  }
  return arr;
}

function drawChart(data){
  if(chartInstance){ chartInstance.destroy(); chartInstance = null; }
  const ctx = document.getElementById('detailChart').getContext('2d');
  chartInstance = new Chart(ctx, {
    type: 'line',
    data: {
      labels: data.map((_,i)=>`T-${data.length-i}`),
      datasets: [{
        label: 'Цена ($)',
        data: data,
        borderColor: '#facc00',
        backgroundColor: 'rgba(250,204,0,0.18)',
        tension: 0.25,
        pointRadius: 2
      }]
    },
    options: { responsive: true, plugins:{legend:{display:false}} }
  });
}

// --- events
document.querySelectorAll('.btn[data-cat]').forEach(b=> b.addEventListener('click', ()=> showCategory(b.dataset.cat)));
document.getElementById('toMain').onclick = ()=> { document.getElementById('screen2').style.display='none'; document.getElementById('screen1').style.display='block'; };
document.getElementById('toList').onclick = ()=> { document.getElementById('screen3').style.display='none'; document.getElementById('screen2').style.display='block'; if(chartInstance){chartInstance.destroy(); chartInstance=null;} };
document.getElementById('refreshBtn').onclick = ()=> { fetchCSVorJSON().then(()=> renderList()); };
downloadBtn.onclick = ()=> { window.open(HF_CSV, '_blank'); };

// Auto-load once
fetchCSVorJSON();

// Auto-refresh every 30s if view on category
setInterval(()=>{ if(CURRENT_CATEGORY) fetchCSVorJSON().then(()=> renderList()); }, 30000);
</script>
</body>
</html>
